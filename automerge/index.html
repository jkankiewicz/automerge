<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Automerge"><title>automerge - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="automerge" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https:///raw.githubusercontent.com/automerge/automerge/main/img/favicon.ico"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../automerge/index.html"><img src="https://raw.githubusercontent.com/automerge/automerge/main/img/brandmark.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../automerge/index.html"><img src="https://raw.githubusercontent.com/automerge/automerge/main/img/brandmark.svg" alt="logo"></a><h2 class="location"><a href="#">Crate automerge</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.5.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">automerge</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/automerge/lib.rs.html#1-311">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="automerge"><a href="#automerge">Automerge</a></h2>
<p>Automerge is a library of data structures for building collaborative,
<a href="https://www.inkandswitch.com/local-first/">local-first</a> applications. The
idea of automerge is to provide a data structure which is quite general,
- consisting of nested key/value maps and/or lists - which can be modified
entirely locally but which can at any time be merged with other instances of
the same data structure.</p>
<p>In addition to the core data structure (which we generally refer to as a
“document”), we also provide an implementation of a sync protocol (in
<a href="sync/index.html" title="mod automerge::sync"><code>crate::sync</code></a>) which can be used over any reliable in-order transport; and
an efficient binary storage format.</p>
<p>This crate is organised around two representations of a document -
<a href="struct.Automerge.html" title="struct automerge::Automerge"><code>Automerge</code></a> and <a href="struct.AutoCommit.html" title="struct automerge::AutoCommit"><code>AutoCommit</code></a>. The difference between the two is that
<a href="struct.AutoCommit.html" title="struct automerge::AutoCommit"><code>AutoCommit</code></a> manages transactions for you. Both of these representations
implement <a href="trait.ReadDoc.html" title="trait automerge::ReadDoc"><code>ReadDoc</code></a> for reading values from a document and
<a href="sync/trait.SyncDoc.html" title="trait automerge::sync::SyncDoc"><code>sync::SyncDoc</code></a> for taking part in the sync protocol. <a href="struct.AutoCommit.html" title="struct automerge::AutoCommit"><code>AutoCommit</code></a>
directly implements <a href="transaction/trait.Transactable.html" title="trait automerge::transaction::Transactable"><code>transaction::Transactable</code></a> for making changes to a
document, whilst <a href="struct.Automerge.html" title="struct automerge::Automerge"><code>Automerge</code></a> requires you to explicitly create a
<a href="transaction/struct.Transaction.html" title="struct automerge::transaction::Transaction"><code>transaction::Transaction</code></a>.</p>
<p>NOTE: The API this library provides for modifying data is quite low level
(somewhat analogous to directly creating JSON values rather than using
<code>serde</code> derive macros or equivalent). If you’re writing a Rust application which uses automerge
you may want to look at <a href="https://github.com/automerge/autosurgeon">autosurgeon</a>.</p>
<h3 id="data-model"><a href="#data-model">Data Model</a></h3>
<p>An automerge document is a map from strings to values
(<a href="enum.Value.html" title="enum automerge::Value"><code>Value</code></a>) where values can be either</p>
<ul>
<li>A nested composite value which is either
<ul>
<li>A map from strings to values (<a href="enum.ObjType.html#variant.Map" title="variant automerge::ObjType::Map"><code>ObjType::Map</code></a>)</li>
<li>A list of values (<a href="enum.ObjType.html#variant.List" title="variant automerge::ObjType::List"><code>ObjType::List</code></a>)</li>
<li>A text object (a sequence of unicode characters) (<a href="enum.ObjType.html#variant.Text" title="variant automerge::ObjType::Text"><code>ObjType::Text</code></a>)</li>
</ul>
</li>
<li>A primitive value (<a href="enum.ScalarValue.html" title="enum automerge::ScalarValue"><code>ScalarValue</code></a>) which is one of
<ul>
<li>A string</li>
<li>A 64 bit floating point number</li>
<li>A signed 64 bit integer</li>
<li>An unsigned 64 bit integer</li>
<li>A boolean</li>
<li>A counter object (a 64 bit integer which merges by addition)
(<a href="enum.ScalarValue.html#variant.Counter" title="variant automerge::ScalarValue::Counter"><code>ScalarValue::Counter</code></a>)</li>
<li>A timestamp (a 64 bit integer which is milliseconds since the unix epoch)</li>
</ul>
</li>
</ul>
<p>All composite values have an ID (<a href="enum.ObjId.html" title="enum automerge::ObjId"><code>ObjId</code></a>) which is created when the value
is inserted into the document or is the root object ID <a href="constant.ROOT.html" title="constant automerge::ROOT"><code>ROOT</code></a>. Values in
the document are then referred to by the pair (<code>object ID</code>, <code>key</code>). The
<code>key</code> is represented by the <a href="enum.Prop.html" title="enum automerge::Prop"><code>Prop</code></a> type and is either a string for a maps,
or an index for sequences.</p>
<h4 id="conflicts"><a href="#conflicts">Conflicts</a></h4>
<p>There are some things automerge cannot merge sensibly. For example, two
actors concurrently setting the key “name” to different values. In this case
automerge will pick a winning value in a random but deterministic way, but
the conflicting value is still available via the <a href="trait.ReadDoc.html#tymethod.get_all" title="method automerge::ReadDoc::get_all"><code>ReadDoc::get_all</code></a> method.</p>
<h4 id="change-hashes-and-historical-values"><a href="#change-hashes-and-historical-values">Change hashes and historical values</a></h4>
<p>Like git, points in the history of a document are identified by hash. Unlike
git there can be multiple hashes representing a particular point (because
automerge supports concurrent changes). These hashes can be obtained using
either <a href="struct.Automerge.html#method.get_heads" title="method automerge::Automerge::get_heads"><code>Automerge::get_heads</code></a> or <a href="struct.AutoCommit.html#method.get_heads" title="method automerge::AutoCommit::get_heads"><code>AutoCommit::get_heads</code></a> (note these
methods are not part of <a href="trait.ReadDoc.html" title="trait automerge::ReadDoc"><code>ReadDoc</code></a> because in the case of <a href="struct.AutoCommit.html" title="struct automerge::AutoCommit"><code>AutoCommit</code></a> it
requires a mutable reference to the document).</p>
<p>These hashes can be used to read values from the document at a particular
point in history using the various <code>*_at</code> methods on <a href="trait.ReadDoc.html" title="trait automerge::ReadDoc"><code>ReadDoc</code></a> which take a
slice of <a href="struct.ChangeHash.html" title="struct automerge::ChangeHash"><code>ChangeHash</code></a> as an argument.</p>
<h4 id="actor-ids"><a href="#actor-ids">Actor IDs</a></h4>
<p>Any change to an automerge document is made by an actor, represented by an
<a href="struct.ActorId.html" title="struct automerge::ActorId"><code>ActorId</code></a>. An actor ID is any random sequence of bytes but each change by
the same actor ID must be sequential. This often means you will want to
maintain at least one actor ID per device. It is fine to generate a new
actor ID for each change, but be aware that each actor ID takes up space in
a document so if you expect a document to be long lived and/or to have many
changes then you should try to reuse actor IDs where possible.</p>
<h4 id="text-encoding"><a href="#text-encoding">Text Encoding</a></h4>
<p>Text is encoded in utf8 by default but uses Utf16 when using the wasm target.</p>
<h3 id="sync-protocol"><a href="#sync-protocol">Sync Protocol</a></h3>
<p>See the <a href="sync/index.html" title="mod automerge::sync"><code>sync</code></a> module.</p>
<h3 id="patches-maintaining-materialized-state"><a href="#patches-maintaining-materialized-state">Patches, maintaining materialized state</a></h3>
<p>Often you will have some state which represents the “current” state of the document. E.g. some
text in a UI which is a view of a text object in the document. Rather than re-rendering this
text every single time a change comes in you can use a <a href="patches/struct.PatchLog.html" title="struct automerge::patches::PatchLog"><code>PatchLog</code></a> to capture incremental
changes made to the document and then use <a href="struct.Automerge.html#method.make_patches" title="method automerge::Automerge::make_patches"><code>Automerge::make_patches</code></a> to get a set of patches
to apply to the materialized state.</p>
<p>Many of the methods on <a href="struct.Automerge.html" title="struct automerge::Automerge"><code>Automerge</code></a>, <a href="sync/trait.SyncDoc.html" title="trait automerge::sync::SyncDoc"><code>crate::sync::SyncDoc</code></a> and
<a href="transaction/trait.Transactable.html" title="trait automerge::transaction::Transactable"><code>crate::transaction::Transactable</code></a> have a <code>*_log_patches</code> variant which allow you to pass in
a <a href="patches/struct.PatchLog.html" title="struct automerge::patches::PatchLog"><code>PatchLog</code></a> to collect these incremental changes.</p>
<h3 id="serde-serialization"><a href="#serde-serialization">Serde serialization</a></h3>
<p>Sometimes you just want to get the JSON value of an automerge document. For
this you can use <a href="struct.AutoSerde.html" title="struct automerge::AutoSerde"><code>AutoSerde</code></a>, which implements <code>serde::Serialize</code> for an
automerge document.</p>
<h3 id="example"><a href="#example">Example</a></h3>
<p>Let’s create a document representing an address book.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>automerge::{ObjType, AutoCommit, transaction::Transactable, ReadDoc};

<span class="kw">let </span><span class="kw-2">mut </span>doc = AutoCommit::new();

<span class="comment">// `put_object` creates a nested object in the root key/value map and
// returns the ID of the new object, in this case a list.
</span><span class="kw">let </span>contacts = doc.put_object(automerge::ROOT, <span class="string">&quot;contacts&quot;</span>, ObjType::List)<span class="question-mark">?</span>;

<span class="comment">// Now we can insert objects into the list
</span><span class="kw">let </span>alice = doc.insert_object(<span class="kw-2">&amp;</span>contacts, <span class="number">0</span>, ObjType::Map)<span class="question-mark">?</span>;

<span class="comment">// Finally we can set keys in the &quot;alice&quot; map
</span>doc.put(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Alice&quot;</span>)<span class="question-mark">?</span>;
doc.put(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;alice@example.com&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Create another contact
</span><span class="kw">let </span>bob = doc.insert_object(<span class="kw-2">&amp;</span>contacts, <span class="number">1</span>, ObjType::Map)<span class="question-mark">?</span>;
doc.put(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>)<span class="question-mark">?</span>;
doc.put(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Now we save the address book, we can put this in a file
</span><span class="kw">let </span>data: Vec&lt;u8&gt; = doc.save();</code></pre></div>
<p>Now modify this document on two separate devices and merge the modifications.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::borrow::Cow;
<span class="kw">use </span>automerge::{ObjType, AutoCommit, transaction::Transactable, ReadDoc};


<span class="comment">// Load the document on the first device and change alices email
</span><span class="kw">let </span><span class="kw-2">mut </span>doc1 = AutoCommit::load(<span class="kw-2">&amp;</span>saved)<span class="question-mark">?</span>;
<span class="kw">let </span>contacts = <span class="kw">match </span>doc1.get(automerge::ROOT, <span class="string">&quot;contacts&quot;</span>)<span class="question-mark">? </span>{
    <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::List), contacts)) =&gt; contacts,
    <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;contacts should be a list&quot;</span>),
};
<span class="kw">let </span>alice = <span class="kw">match </span>doc1.get(<span class="kw-2">&amp;</span>contacts, <span class="number">0</span>)<span class="question-mark">? </span>{
   <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::Map), alice)) =&gt; alice,
   <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;alice should be a map&quot;</span>),
};
doc1.put(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;email&quot;</span>, <span class="string">&quot;alicesnewemail@example.com&quot;</span>)<span class="question-mark">?</span>;


<span class="comment">// Load the document on the second device and change bobs name
</span><span class="kw">let </span><span class="kw-2">mut </span>doc2 = AutoCommit::load(<span class="kw-2">&amp;</span>saved)<span class="question-mark">?</span>;
<span class="kw">let </span>contacts = <span class="kw">match </span>doc2.get(automerge::ROOT, <span class="string">&quot;contacts&quot;</span>)<span class="question-mark">? </span>{
   <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::List), contacts)) =&gt; contacts,
   <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;contacts should be a list&quot;</span>),
};
<span class="kw">let </span>bob = <span class="kw">match </span>doc2.get(<span class="kw-2">&amp;</span>contacts, <span class="number">1</span>)<span class="question-mark">? </span>{
  <span class="prelude-val">Some</span>((automerge::Value::Object(ObjType::Map), bob)) =&gt; bob,
  <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;bob should be a map&quot;</span>),
};
doc2.put(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Robert&quot;</span>)<span class="question-mark">?</span>;

<span class="comment">// Finally, we can merge the changes from the two devices
</span>doc1.merge(<span class="kw-2">&amp;mut </span>doc2)<span class="question-mark">?</span>;
<span class="kw">let </span>bobsname: <span class="prelude-ty">Option</span>&lt;automerge::Value&gt; = doc1.get(<span class="kw-2">&amp;</span>bob, <span class="string">&quot;name&quot;</span>)<span class="question-mark">?</span>.map(|(v, <span class="kw">_</span>)| v);
<span class="macro">assert_eq!</span>(bobsname, <span class="prelude-val">Some</span>(automerge::Value::Scalar(Cow::Owned(<span class="string">&quot;Robert&quot;</span>.into()))));

<span class="kw">let </span>alices_email: <span class="prelude-ty">Option</span>&lt;automerge::Value&gt; = doc1.get(<span class="kw-2">&amp;</span>alice, <span class="string">&quot;email&quot;</span>)<span class="question-mark">?</span>.map(|(v, <span class="kw">_</span>)| v);
<span class="macro">assert_eq!</span>(alices_email, <span class="prelude-val">Some</span>(automerge::Value::Scalar(Cow::Owned(<span class="string">&quot;alicesnewemail@example.com&quot;</span>.into()))));</code></pre></div>
<h3 id="cursors-referring-to-positions-in-sequences"><a href="#cursors-referring-to-positions-in-sequences">Cursors, referring to positions in sequences</a></h3>
<p>When working with text or other sequences it is often useful to be able to
refer to a specific position within the sequence whilst merging remote
changes. You can manually do this by maintaining your own offsets and
observing patches, but this is error prone. The <code>Cursor</code> type provides
an API for allowing automerge to do the index translations for you. Cursors
are created with <a href="trait.ReadDoc.html#tymethod.get_cursor" title="method automerge::ReadDoc::get_cursor"><code>ReadDoc::get_cursor</code></a> and dereferneced with
<a href="trait.ReadDoc.html#tymethod.get_cursor_position" title="method automerge::ReadDoc::get_cursor_position"><code>ReadDoc::get_cursor_position</code></a>.</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Patch"><code>pub use patches::<a class="struct" href="patches/struct.Patch.html" title="struct automerge::patches::Patch">Patch</a>;</code></div></li><li><div class="item-name" id="reexport.PatchAction"><code>pub use patches::<a class="enum" href="patches/enum.PatchAction.html" title="enum automerge::patches::PatchAction">PatchAction</a>;</code></div></li><li><div class="item-name" id="reexport.PatchLog"><code>pub use patches::<a class="struct" href="patches/struct.PatchLog.html" title="struct automerge::patches::PatchLog">PatchLog</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="hydrate/index.html" title="mod automerge::hydrate">hydrate</a></div></li><li><div class="item-name"><a class="mod" href="iter/index.html" title="mod automerge::iter">iter</a></div></li><li><div class="item-name"><a class="mod" href="marks/index.html" title="mod automerge::marks">marks</a></div></li><li><div class="item-name"><a class="mod" href="op_tree/index.html" title="mod automerge::op_tree">op_tree</a></div></li><li><div class="item-name"><a class="mod" href="patches/index.html" title="mod automerge::patches">patches</a></div></li><li><div class="item-name"><a class="mod" href="sync/index.html" title="mod automerge::sync">sync</a></div><div class="desc docblock-short">Sync Protocol</div></li><li><div class="item-name"><a class="mod" href="transaction/index.html" title="mod automerge::transaction">transaction</a></div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.hydrate_list.html" title="macro automerge::hydrate_list">hydrate_list</a></div></li><li><div class="item-name"><a class="macro" href="macro.hydrate_map.html" title="macro automerge::hydrate_map">hydrate_map</a></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ActorId.html" title="struct automerge::ActorId">ActorId</a></div><div class="desc docblock-short">An actor id is a sequence of bytes. By default we use a uuid which can be nicely stack
allocated.</div></li><li><div class="item-name"><a class="struct" href="struct.AutoCommit.html" title="struct automerge::AutoCommit">AutoCommit</a></div><div class="desc docblock-short">An automerge document that automatically manages transactions.</div></li><li><div class="item-name"><a class="struct" href="struct.AutoSerde.html" title="struct automerge::AutoSerde">AutoSerde</a></div><div class="desc docblock-short">A wrapper type which implements <a href="https://docs.rs/serde/1.0.188/serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>serde::Serialize</code></a> for a <a href="trait.ReadDoc.html" title="trait automerge::ReadDoc"><code>ReadDoc</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Automerge.html" title="struct automerge::Automerge">Automerge</a></div><div class="desc docblock-short">An automerge document which does not manage transactions for you.</div></li><li><div class="item-name"><a class="struct" href="struct.Change.html" title="struct automerge::Change">Change</a></div></li><li><div class="item-name"><a class="struct" href="struct.ChangeHash.html" title="struct automerge::ChangeHash">ChangeHash</a></div><div class="desc docblock-short">The sha256 hash of a change.</div></li><li><div class="item-name"><a class="struct" href="struct.Cursor.html" title="struct automerge::Cursor">Cursor</a></div><div class="desc docblock-short">An identifier of a position in a Sequence (either Self::List or Self::Text).</div></li><li><div class="item-name"><a class="struct" href="struct.ExpandedChange.html" title="struct automerge::ExpandedChange">ExpandedChange</a></div><div class="desc docblock-short">A change represents a group of operations performed by an actor.</div></li><li><div class="item-name"><a class="struct" href="struct.InvalidActorId.html" title="struct automerge::InvalidActorId">InvalidActorId</a></div></li><li><div class="item-name"><a class="struct" href="struct.InvalidChangeHashSlice.html" title="struct automerge::InvalidChangeHashSlice">InvalidChangeHashSlice</a></div></li><li><div class="item-name"><a class="struct" href="struct.Parent.html" title="struct automerge::Parent">Parent</a></div><div class="desc docblock-short">A component of a path to an object</div></li><li><div class="item-name"><a class="struct" href="struct.Parents.html" title="struct automerge::Parents">Parents</a></div><div class="desc docblock-short">An iterator over the “parents” of an object</div></li><li><div class="item-name"><a class="struct" href="struct.SaveOptions.html" title="struct automerge::SaveOptions">SaveOptions</a></div><div class="desc docblock-short">Options to pass to <code>[Automerge::save_with_options]</code> and <a href="struct.AutoCommit.html#method.save_with_options" title="method automerge::AutoCommit::save_with_options"><code>crate::AutoCommit::save_with_options</code></a></div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AutomergeError.html" title="enum automerge::AutomergeError">AutomergeError</a></div></li><li><div class="item-name"><a class="enum" href="enum.LoadChangeError.html" title="enum automerge::LoadChangeError">LoadChangeError</a></div></li><li><div class="item-name"><a class="enum" href="enum.ObjId.html" title="enum automerge::ObjId">ObjId</a></div><div class="desc docblock-short">An identifier for an object in a document</div></li><li><div class="item-name"><a class="enum" href="enum.ObjIdFromBytesError.html" title="enum automerge::ObjIdFromBytesError">ObjIdFromBytesError</a></div></li><li><div class="item-name"><a class="enum" href="enum.ObjType.html" title="enum automerge::ObjType">ObjType</a></div><div class="desc docblock-short">The type of an object</div></li><li><div class="item-name"><a class="enum" href="enum.OnPartialLoad.html" title="enum automerge::OnPartialLoad">OnPartialLoad</a></div><div class="desc docblock-short">What to do when loading a document partially succeeds</div></li><li><div class="item-name"><a class="enum" href="enum.OpType.html" title="enum automerge::OpType">OpType</a></div></li><li><div class="item-name"><a class="enum" href="enum.ParseChangeHashError.html" title="enum automerge::ParseChangeHashError">ParseChangeHashError</a></div></li><li><div class="item-name"><a class="enum" href="enum.Prop.html" title="enum automerge::Prop">Prop</a></div><div class="desc docblock-short">A property of an object</div></li><li><div class="item-name"><a class="enum" href="enum.ScalarValue.html" title="enum automerge::ScalarValue">ScalarValue</a></div><div class="desc docblock-short">A value which is not a composite value</div></li><li><div class="item-name"><a class="enum" href="enum.Value.html" title="enum automerge::Value">Value</a></div><div class="desc docblock-short">The type of values in an automerge document</div></li><li><div class="item-name"><a class="enum" href="enum.VerificationMode.html" title="enum automerge::VerificationMode">VerificationMode</a></div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.ROOT.html" title="constant automerge::ROOT">ROOT</a></div><div class="desc docblock-short">The object ID for the root map of a document</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ReadDoc.html" title="trait automerge::ReadDoc">ReadDoc</a></div><div class="desc docblock-short">Methods for reading values from an automerge document</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.SequenceTree.html" title="type automerge::SequenceTree">SequenceTree</a></div></li></ul></section></div></main></body></html>